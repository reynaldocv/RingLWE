# This file was *autogenerated* from the file test.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1024 = Integer(1024); _sage_const_12289 = Integer(12289); _sage_const_8 = Integer(8); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_p5 = RealNumber('.5'); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_100 = Integer(100)
import sys

n = _sage_const_1024 
q = _sage_const_12289 
r = _sage_const_8 

R = PolynomialRing(Integers(q),"y")
x = R.gen()
S = R.quotient(x**n + _sage_const_1 , 'x')
w = S.gen()

def smallPolynomial(times):
    ans = _sage_const_0  
    for i in range(n):
        coeff = _sage_const_0 
        for _ in range(times):
            bit1 = randint(_sage_const_0 , _sage_const_1 )
            bit2 = randint(_sage_const_0 , _sage_const_1 )
            coeff += (bit1 - bit2)
    
        ans += w**i*coeff
    
    return ans

def rounding(num):
    return int(num + _sage_const_p5 )
    
def inverse(small):
    MatrixA = []
    for i in range(n):
        aux = small*w**(n - i - _sage_const_1 )
        vetorA = [aux[n - i - _sage_const_1 ] for i in range(n)]
        MatrixA.append(list(vetorA))   

    MatrixA = MatrixA[::-_sage_const_1 ]

    MA = matrix(GF(q), MatrixA)

    Y = [_sage_const_0  for _ in range(n)]
    Y[-_sage_const_1 ] = _sage_const_1 

    Z = MA.solve_right(vector(GF(q), Y))

    zPol = _sage_const_0 
    for (i, val) in enumerate(Z):
        zPol += val*w**i
    
    return zPol 

case = int(sys.argv[_sage_const_1 ])
erro = int(sys.argv[_sage_const_2 ])
limit = int(sys.argv[_sage_const_3 ])

m = q//(_sage_const_2 *r + _sage_const_1 )


exp = _sage_const_0  

recoveredKeys = _sage_const_0  
recoveredCoeff = _sage_const_0  

counter = {}
duplicates = {}

while exp < limit: 
	try:
		if case == _sage_const_2 : 
			c = smallPolynomial(erro)
			cInv = inverse(c)
			a = cInv*m
		if case == _sage_const_3 : 
			c = smallPolynomial(erro)
			d = smallPolynomial(erro)

			cInv = inverse(c)
			a = cInv*(m + d)
			
		for i in range(_sage_const_100 ):			
			s = smallPolynomial(r)
			e = smallPolynomial(r)

			b = a*s + e

			b2 = b*c

			cnt = _sage_const_0 

			for i in range(n):
				coeffsi = s[i]
				if coeffsi < q//_sage_const_2 : 
					coeffsi2 = rounding(float(b2[i])/m) % (_sage_const_2 *r + _sage_const_1  )        
				else: 
					coeffsi2 =  (-_sage_const_1 *(_sage_const_2 *r + _sage_const_1  - (rounding(float(b2[i])/m) % (_sage_const_2 *r + _sage_const_1  )))) % q
					
				if coeffsi != coeffsi2:
					cnt += _sage_const_1 	
				else: 
					recoveredCoeff += _sage_const_1  
					
			if cnt == _sage_const_0 : 
				recoveredKeys += _sage_const_1  		

			counter[cnt] = counter.get(cnt, _sage_const_0 ) + _sage_const_1 

		exp += _sage_const_1  
	except: 
		print("+")
		continue
		
print("case", case)
print("erro", erro)
print("recovered keys ", recoveredKeys)
print("recovered Coeff", recoveredCoeff)
print("-----------------------------------")

for key in range(_sage_const_1024 ): 
	if key in counter: 
		print("chaves con coeff errados", key, ">", counter[key])





